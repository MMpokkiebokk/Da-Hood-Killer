local assert = assert
local type = type
local setfenv = setfenv
local getfenv = getfenv
local hookfunction = hookfunction
local getconnections = getconnections
local getgc = getgc
local setreadonly = setreadonly
local rawget = rawget
local rawset = rawset
local table = table
local coroutine = coroutine
local game = game
local newcclosure = newcclosure
local getnamecallmethod = getnamecallmethod
local pcall = pcall

 local jugg = {}
jugg.__index = jugg
local this = setmetatable({}, jugg)
function jugg.new()
      
    this._jugg_grandma = false
    local ts = this
    ts._jugg_grandma = true
    return this
end
 
function jugg:grandma()
    return this._jugg_grandma , self._jugg_grandma
end

local instance = jugg.new()
local RunService = game:GetService("RunService")
     instance:grandma()
 local function validateArguments(args, expectedTypes, funcName)
    for i, expectedType in ipairs(expectedTypes) do
        if type(args[i]) ~= expectedType then
            return false, funcName .. ": invalid argument #" .. i
        end
    end
    return true
end

local function LPH_ENCHUM(toEncrypt)
    local valid, err = validateArguments({toEncrypt}, {"number"}, "LPH_ENCHUM")
    if not valid then return nil, err end
    return toEncrypt
end

local function LPH_ENCSTR(toEncrypt)
    local valid, err = validateArguments({toEncrypt}, {"string"}, "LPH_ENCSTR")
    if not valid then return nil, err end
    return toEncrypt
end

local function LPH_ENFUNC(toEncrypt, encKey, decKey)
    local valid, err = validateArguments({toEncrypt, encKey, decKey}, {"function", "string", "string"}, "LPH_ENFUNC")
    if not valid then return nil, err end
    return toEncrypt
end

local function LPH_ENCRYPT(data, key)
    local valid, err = validateArguments({data, key}, {"string", "string"}, "LPH_ENCRYPT")
    if not valid then return nil, err end
    return data
end

local function LPH_ENCODE(value, encoder)
    local valid, err = validateArguments({value, encoder}, {"string", "string"}, "LPH_ENCODE")
    if not valid then return nil, err end
    return value
end

local function LPH_OBFUSCATE(code, level)
    local valid, err = validateArguments({code, level}, {"function", "number"}, "LPH_OBFUSCATE")
    if not valid then return nil, err end
    return code
end

local function LPH_VIRTUALIZE(func, options)
    local valid, err = validateArguments({func, options}, {"function", "table"}, "LPH_VIRTUALIZE")
    if not valid then return nil, err end
    return func
end

local function LPH_DEEP_VIRTUALIZE(func, virtualizeOptions)
    local valid, err = validateArguments({func, virtualizeOptions}, {"function", "table"}, "LPH_DEEP_VIRTUALIZE")
    if not valid then return nil, err end
    return func
end

local function LPH_PROTECT(data, method)
    local valid, err = validateArguments({data, method}, {"table", "string"}, "LPH_PROTECT")
    if not valid then return nil, err end
    return data
end

local function LPH_SECURE(data, securityLevel)
    local valid, err = validateArguments({data, securityLevel}, {"string", "number"}, "LPH_SECURE")
    if not valid then return nil, err end
    return data
end

local function LPH_SHIELD(script, protectionLevel)
    local valid, err = validateArguments({script, protectionLevel}, {"string", "number"}, "LPH_SHIELD")
    if not valid then return nil, err end
    return script
end

local function LPH_ANTITAMP(func, checksum)
    local valid, err = validateArguments({func, checksum}, {"function", "string"}, "LPH_ANTITAMP")
    if not valid then return nil, err end
    return func
end

local function LPH_INTEGRITY(data, hashMethod)
    local valid, err = validateArguments({data, hashMethod}, {"string", "string"}, "LPH_INTEGRITY")
    if not valid then return nil, err end
    return data
end

local function LPH_BYPASS_CHECK(checkFunction, bypassMethod)
    local valid, err = validateArguments({checkFunction, bypassMethod}, {"function", "string"}, "LPH_BYPASS_CHECK")
    if not valid then return nil, err end
    return checkFunction
end

local function LPH_NETBYPASS(networkFunc, bypassLevel)
    local valid, err = validateArguments({networkFunc, bypassLevel}, {"function", "number"}, "LPH_NETBYPASS")
    if not valid then return nil, err end
    return networkFunc
end

local function LPH_JIT(f)
    local valid, err = validateArguments({f}, {"function"}, "LPH_JIT")
    if not valid then return nil, err end
    return f
end

local function LPH_NOVIRTUALIZE(f)
    local valid, err = validateArguments({f}, {"function"}, "LPH_NOVIRTUALIZE")
    if not valid then return nil, err end
    return f
end

local function LPH_NO_UPVALUE(f)
    local valid, err = validateArguments({f}, {"function"}, "LPH_NO_UPVALUE")
    if not valid then return nil, err end
    return f
end

local function LPH_ULTRA_ENCRYPT(data, ultraKey, complexity)
    local valid, err = validateArguments({data, ultraKey, complexity}, {"string", "string", "number"}, "LPH_ULTRA_ENCRYPT")
    if not valid then return nil, err end
    return data
end

local function LPH_QUANTUM_GUARD(code, quantumLevel)
    local valid, err = validateArguments({code, quantumLevel}, {"function", "number"}, "LPH_QUANTUM_GUARD")
    if not valid then return nil, err end
    return code
end

local function bypassAntiCheat()
    local function hax(e)
        for _, v in next, getconnections(e) do
            v:Disconnect()
        end
    end

    hax(game:GetService("ScriptContext").Error)
    hookfunction(game.LogService.MessageOut.Connect, function() end)
    hookfunction(game:GetService("ScriptContext").Error.Connect, function() end)
    hookfunction(setfenv, function()
        return coroutine.yield()
    end)

    local Bypass = false

    for Key, Object in pairs(getgc(true)) do
        if type(Object) == "table" then
            setreadonly(Object, false)
            local indexInstance = rawget(Object, "indexInstance")
            if type(indexInstance) == "table" and indexInstance[1] == "kick" then
                setreadonly(indexInstance, false)
                rawset(Object, "Table", {"kick", function() coroutine.yield() end})
                Bypass = true
                break
            end
        end
    end

    local GameMT = getrawmetatable(game)
    local OldIndexFunc = GameMT.__index
    local OldNamecallFunc = GameMT.__namecall
    setreadonly(GameMT, false)

    if Bypass then
        GameMT.__namecall = newcclosure(function(self, ...)
            local NamecallArgs = {...}
            local DETECTION_STRINGS = {
                'CHECKER_1', 'CHECKER', 'OneMoreTime', 'checkingSPEED', 'PERMAIDBAN', 'BANREMOTE', 'FORCEFIELD', 'TeleportDetect'
            }

            if table.find(DETECTION_STRINGS, NamecallArgs[1]) and getnamecallmethod() == 'FireServer' then
                return
            end

            local suc, err = pcall(getfenv, 2)
            if not err and getfenv(2).crash then
                hookfunction(getfenv(2).crash, function() end)
            end

            return OldNamecallFunc(self, ...)
        end)
    end
end

bypassAntiCheat()

return {
    LPH_ENCHUM = LPH_ENCHUM,
    LPH_ENCSTR = LPH_ENCSTR,
    LPH_ENFUNC = LPH_ENFUNC,
    LPH_ENCRYPT = LPH_ENCRYPT,
    LPH_ENCODE = LPH_ENCODE,
    LPH_OBFUSCATE = LPH_OBFUSCATE,
    LPH_VIRTUALIZE = LPH_VIRTUALIZE,
    LPH_DEEP_VIRTUALIZE = LPH_DEEP_VIRTUALIZE,
    LPH_PROTECT = LPH_PROTECT,
    LPH_SECURE = LPH_SECURE,
    LPH_SHIELD = LPH_SHIELD,
    LPH_ANTITAMP = LPH_ANTITAMP,
    LPH_INTEGRITY = LPH_INTEGRITY,
    LPH_BYPASS_CHECK = LPH_BYPASS_CHECK,
    LPH_NETBYPASS = LPH_NETBYPASS,
    LPH_JIT = LPH_JIT,
    LPH_NOVIRTUALIZE = LPH_NOVIRTUALIZE,
    LPH_NO_UPVALUE = LPH_NO_UPVALUE,
    LPH_ULTRA_ENCRYPT = LPH_ULTRA_ENCRYPT,
    LPH_QUANTUM_GUARD = LPH_QUANTUM_GUARD
}
